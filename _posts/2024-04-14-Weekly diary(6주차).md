---
layout: single
title:  "Weekly Diary 6주차(2024.04.08 ~ 2024.04.14)"
excerpt: "6주차 개발 기록 정리"
categories: WeeklyㅤDiary
# tag: [python, blog, food]
toc: true
toc_sticky: true
typora-root-url: ../
auto_profile: false
# sidebar:
#    nav: "docs"
# search: false
---



# **1. 주간 활동 정리**

## **1) 활동 기록**

**[주간 정규 회의 및 활동 기록]**  
2024-04-08 (월) 12:30 ~ 22:30    
2024-04-09 (화) 18:00 ~ 22:00
2024-04-10 (수) 11:00 ~ 21:30   
2024-04-11 (목) **[11:00 ~ 12:00]**, 12:00 ~ 18:00   
총 활동 시간: 31시간 30분    
**<u>대괄호로 작성된 부분은 정규 회의 시간임.</u>*  
{: .notice--danger .text-center}

## **2) 개발 기록**

이번 주차는 지난 주차에서 제작하던 H/W 환경을 정밀하게 완성하여 라즈베리파이와 카메라 구동을 통한 촬영 환경 완성을 목표로 한다. 

<br>

------

# 2. H/W 진행 사항

> 프로젝트의 전체적인 프레임은 갖춰진 상태이나, 작은 하드웨어 부품, 배선, 그리고 시트지를 고려하여 임시로 붙여놓은 아크릴을 정밀하게 부착할 필요가 있다. 아크릴은 시트지를 부착한 후 프레임에 정밀하게 고정하는 순서로 진행한다. 모듈부와 측정부의 문은 경첩을 사용하여 균형을 맞추고 빈틈없이 고정한다. 또한, 모듈부에서 사용할 카메라 거치대는 레이저 커팅기로 아크릴을 재단하여 제작한다. 카메라 구동이 확인된 후에는 측정부의 Target Area를 카메라를 기준으로 미세하게 조정이 필요하다.

## **1) 시트지 부착 및 아크릴 고정**

> 프레임에 아크릴을 완전히 고정하고 정밀하게 제작하기 위해, 완전히 고정하지 않은 아크릴 부착 전에 시트지를 미리 붙인다. 이미 고정한 아크릴에는 크기에 맞춰 시트지를 부착한다.

![image-20240414215023268](/images/2024-04-14-Weekly diary(6주차)/image-20240414215023268.png){: .img-default-setting}

![image-20240414215033860](/images/2024-04-14-Weekly diary(6주차)/image-20240414215033860.png){: .img-default-setting}

![image-20240414215042330](/images/2024-04-14-Weekly diary(6주차)/image-20240414215042330.png){: .img-default-setting}

![image-20240414215051853](/images/2024-04-14-Weekly diary(6주차)/image-20240414215051853.png){: .img-default-setting}

<br>

## **2) 앞문 경첩 부착**

> 'ㄱ' 형태의 아크릴 앞판과 바닥면 아크릴을 정밀하게 맞추어 측정부로 빛이 유입되지 않도록 경첩으로 고정한다. 또한, 문 안쪽 벽에 자석을 부착하여 문이 완전히 닫히고 유지되도록 할 계획이다.

![image-20240414215105709](/images/2024-04-14-Weekly diary(6주차)/image-20240414215105709.png){: .img-default-setting}

![image-20240414215115263](/images/2024-04-14-Weekly diary(6주차)/image-20240414215115263.png){: .img-default-setting}

<br>

## **3) 레이저 커팅기를 이용한 카메라 거치대 제작**

> 레이저 커팅을 한 아크릴과 보드롱으로 카메라 거치대를 제작하였다. 거치대의 높이는 카메라 높이를 고려하여 77mm로 결정하였다. 

![image-20240414215125091](/images/2024-04-14-Weekly diary(6주차)/image-20240414215125091.png){: .img-default-setting}

=> <u>*레이저 커팅기의 8mm 너비 오차를 고려하여 69mm로 커팅을 설계했음.*</u>

<br>

![image-20240414215156764](/images/2024-04-14-Weekly diary(6주차)/image-20240414215156764.png){: .img-default-setting}

=> <u>제작된 거치대에 카메라가 고정되어 있는 모습</u>

<br>

![image-20240414215227790](/images/2024-04-14-Weekly diary(6주차)/image-20240414215227790.png){: .img-default-setting}

=> <u>카메라 모듈부의 상단에서 촬영한 이미지</u>

<br>

## **4) Target Area 조정**

> 측정부 천장의 카메라 구멍 위치와 바닥면 중앙을 정밀하게 일치시켜 Target Area를 구성하였다. 이 Target Area는 한 변의 길이가 80mm인 정사각형 형태로, 측정에 영향을 주지 않도록 무광 암막 시트지를 사용하여 표기하였다.

<br>

## 5) 바닥 프레임 제작

> 모듈부 문을 고정하는 아크릴이 돌출형이므로 H/W가 기울어지지 않게 지지하는 바닥 지지대가 필요하였다. 따라서 철제 프레임을 활용하여 전체 H/W를 견고하게 지지하며 바닥면 아크릴의 변형을 방지하도록 제작하였다.

![image-20240414215405113](/images/2024-04-14-Weekly diary(6주차)/image-20240414215405113.png){: .img-default-setting}

<br>

## 6) 기타 조정

> TPG 측정을 위해 필요한 H/W를 모두 배치하고 고정하였다. 

![image-20240414215419322](/images/2024-04-14-Weekly diary(6주차)/image-20240414215419322.png){: .img-default-setting}

<br>

# 3. Clustering 팀

> 지금까지 테스트해보았던 클러스터링 알고리즘을 실제로 구현된 환경에서 촬영한 이미지에 적용해보았다. 그리고 해당 과정에서 DBSCAN방식의 클러스터링의 한계를 인식해 이를 해결할 방법을 구상해 보았다.

## 1) 구성된 H/W환경에서의 DBSCAN 테스트

![image-20240414215431972](/images/2024-04-14-Weekly diary(6주차)/image-20240414215431972.png){: .img-default-setting}

위 사진은 시스템 환경에서 촬영한 사진을 확대한 것이다. 위와 같이 확대했을 때, 원사(*원단의 기본 단위. 실 하나를 말함*)가 직조 되어 생기는 연결부에서 원단 스와치의 색깔보다 전반적으로 어둡게 보이는 부분이 존재하는 것을 알 수 있다. 단색상 원단 스와치에서 해당 스와치의 색상은 하나이지만, 원사의 직조에 의해서 필연적으로 주변보다 어두워 색상이 매우 다른 부분이 존재하게 된다. 이는 대표 색상을 추출하고자 한다면 다색상 원단이 아니더라도 클러스터링이 필요할수도 있다는 결과를 시사한다고 볼 수 있다.

<br>

![image-20240414215900917](/images/2024-04-14-Weekly diary(6주차)/image-20240414215900917.png){: .img-default-setting}

따라서 해당 이미지의 원본 이미지에 대해서 기존 *Scikit-learn DBSCAN* 알고리즘을 적용해 보았다.  
(*단, 본 기록은 H/W 진행사항의 4번 토픽에서 제시된 Target Area 조정이 아직 진행되지 않은 상태임에 유의*)

<br>

하지만 코랩에서 실행했을때  *시스템 RAM을 초과 사용해 세션이 종료되는 문제*가 있었다. 이유는 이미지의 해상도가 4056x3040으로 매우 고화질이고 DBSCAN이 이런 고해상도의 이미지에서 엄청나게 느리고 사용하는 리소스가 많기 때문이다. 이는 **K-means 알고리즘**과의 차이에서 더욱 나타나는데 **K-means 알고리즘**은 각 데이터 포인트를 중심과의 거리 기반으로 클러스터에 할당하는 간단한 반복 알고리즘이지만 **DBSCAN 알고리즘**은 데이터가 밀집된 지역을 기준으로 클러스터를 형성하며 더 많은 메모리와 계산량을 필요로하기 때문이다.

<br>

>  **해당 문제점을 인식했기 때문에 고안한 방법은 다음과 같다.**

- 이미지를 crop해서 저해상도의 이미지를 사용한다.
- K-means 알고리즘을 사용한다.
- 저해상도의 cropped 이미지를 DBSCAN으로 클러스터의 개수만 추출하고 K-means 알고리즘을 사용한다.
- 이미지에 차원을 축소하거나 특징을 추출하는 등의 전처리 과정을 적용하고 DBSCAN을 사용한다.
- GPU 지원이 불가능한 scikit-learn의 DBSCAN을 사용하지 않고 자체적으로  DBSCAN 알고리즘을 pytorch로 구현한다.

<br>

## 2)DBSCAN의 확인된 문제 해결

> 6주차 역시 H/W 완성으로 인한 시간적 제한으로 앞선 모든 방법을 시도할수는 없었다. 그렇기 때문에 가능한만큼 진행하고 부족한 부분은 다음주의 To do list에 포함시켜 추가 조사 이후 진행하기로 결정했다.

### **이미지 crop을 통한 저해상도 이미지 DBSCAN**

![image-20240414220009076](/images/2024-04-14-Weekly diary(6주차)/image-20240414220009076.png){: .img-default-setting}

4056x3040의 고해상도 원본 이미지에서 일정 비율대로 이미지를 축소시켜가면서 어느정도의 크기의 이미지가 시스템 RAM한계를 벗어나지 않는지 실험적으로 측정했다. 그 결과 대략적으로  350x300정도의 이미지가 세션이 종료되지 않고 결과를 얻을 수 있었다.

> 하지만 이때 역시 문제가 발생했다.

![image-20240414220732371](/images/2024-04-14-Weekly diary(6주차)/image-20240414220732371.png){: .img-default-setting}

> 각 클러스터의 대표값으로 나타나게 했을 때 클러스터링이 잘 되지 않은 결과를 확인했다. 또한 다른 색상으로 했을때도 비슷한 결과를 얻었으며, 결과는 아래 이미지로 제시하였다.

![image-20240414220750668](/images/2024-04-14-Weekly diary(6주차)/image-20240414220750668.png){: .img-default-setting}

![image-20240414220800149](/images/2024-04-14-Weekly diary(6주차)/image-20240414220800149.png){: .img-default-setting}

<br>

![image-20240414220813645](/images/2024-04-14-Weekly diary(6주차)/image-20240414220813645.png){: .img-default-setting}

![image-20240414220826924](/images/2024-04-14-Weekly diary(6주차)/image-20240414220826924.png){: .img-default-setting}

=> <u>다색상 원단에 대해서는 색상 군집을 구분하기는 하나, 비슷한 결과를 보였다.</u>

<br>

### K-means 알고리즘 사용

![image-20240414220906604](/images/2024-04-14-Weekly diary(6주차)/image-20240414220906604.png){: .img-default-setting}

K-means 알고리즘은 클러스터의 개수를 미리 지정해야 하기 때문에, 하단 이미지에서 대략적으로 보이는 2~4개를 지정해서 적용해보았다.



![image-20240414220933785](/images/2024-04-14-Weekly diary(6주차)/image-20240414220933785.png){: .img-width-large}

이를 각 픽셀의 클러스터 색상으로 적용했을 때, 결과는 다음과 같다.

<br>

![image-20240414221008982](/images/2024-04-14-Weekly diary(6주차)/image-20240414221008982.png){: .img-width-large}

=> **원사 사이사이의 음영 부분을 DBSCAN보다 훨씬 뛰어나게 구분해내는 것을 볼 수 있다.**

<br>

![image-20240414221038924](/images/2024-04-14-Weekly diary(6주차)/image-20240414221038924.png){: .img-default-setting}

>  위에서 진행한 같은 다색상 이미지에 K-means 알고리즘을 적용해 보았다.

![image-20240414221051843](/images/2024-04-14-Weekly diary(6주차)/image-20240414221051843.png){: .img-width-large}

클러스터의 개수를 5개부터 8개까지 변화시켰을 때의 결과를 보면, 실이 삐져나온 부분이나 엮인 부분이 DBSCAN보다 깔끔하게 구분되었지만, 좌상단의 분홍색이 부정확하게 나오는 등의 문제를 보여 완벽하지는 않았다.

<br>

> 또한 앞서 언급된 문제였던 고해상도 이미지의 DBSCAN에서 발생하는 문제는, K-means 알고리즘을 사용하면서 해결 할 수 있었다.

![image-20240414215900917](/images/2024-04-14-Weekly diary(6주차)/image-20240414215900917.png){: .img-default-setting}

계속 사용했던 4056x3040 이미지에 K-Means를 적용했을 때의 결과는 다음과 같다.

![image-20240414221153351](/images/2024-04-14-Weekly diary(6주차)/image-20240414221153351.png){: .img-width-large}

![image-20240414221202900](/images/2024-04-14-Weekly diary(6주차)/image-20240414221202900.png){: .img-width-large}

=> **고해상도 이미지에서도 클러스터가 명확하게 잘 구분된 것을 확인 할 수 있다.**

<br>

### **저해상도 DBSCAN으로 클러스터의 개수만 추출하고 K-means 알고리즘을 사용**

이 방법은 DBSCAN을 통해 클러스터 몇 개로 구분되는지만 확인하고, K-means 알고리즘에 인자로 넘겨주는 방식이기 때문에, 2)번의 방식에서 사람이 클러스터의 개수를 정하지 않고 DBSCAN이 정해주는 차이만 존재한다.

<br>

### 전처리 과정을 적용하고 DBSCAN을 사용

FFT, 다운 샘플링 등의 전처리를 적용하여 더 빠르고 정확한 방식으로 DBSCAN을 적용할 수 있도록 한다.

<br>

### 자체적으로  DBSCAN 알고리즘을 pytorch로 구현

> 전처리 방식과 자체 구현 방식은 시간과 난이도를 고려해서 다음 주 계획에 포함하여, 보다 자세히 조사 및 공부를 하고 진행하기로 했다.

<br>

# 4. Calibration 팀

> H/W가 완성되고 촬영할 수 있는 환경이 조성되었다. 기본 스와치와 TPG를 촬영해본 결과, 지역별 조도 차이와 촬영물 색상에 따른 자동 보정이 존재함을 확인하였다. 우선적으로는 촬영 과정을 간소화하고, 지역별 조도 차이에 따른 색차를 3차원 히스토그램 형태로 분석할 수 있는 방안을 마련할 계획이다.

<br>

## **1) 스와치 촬영 및 분석**

![image-20240414221305600](/images/2024-04-14-Weekly diary(6주차)/image-20240414221305600.png){: .img-default-setting}

![image-20240414221315103](/images/2024-04-14-Weekly diary(6주차)/image-20240414221315103.png){: .img-default-setting}

![image-20240414221323310](/images/2024-04-14-Weekly diary(6주차)/image-20240414221323310.png){: .img-default-setting}

위의 사진들을 통해 **스와치 색조**에 따른 **자동 색온도 보정**이 되는 사실을 확인할 수 있다. 카메라의 내부적인 색상 처리 알고리즘이 적용된 건지, 카메라 센서 민감도에 따른 변화인지, 혹은 그 외의 요인으로 인한 것인지는 알 수 없다. 촬영물의 정확한 색상을 추출하기 위해서는 이를 보정할 필요가 있다. **현재 고려해 본 보정 방법은 촬영물이 존재하지 않는 상태의 아크릴 색상이 촬영물이 존재할 경우에도 동일하게 유지될 수 있는 자체적인 색상 Balancing이다.** 이는 더 많은 촬영을 통해 원인을 분석해보고 더 좋은 방안을 마련하기로 한다. 지역별 조도 차이에 의한 색상 차이가 존재하는지 또한, 더 많은 촬영 데이터를 확보한 뒤에 분석해보기로 한다.

<br>

## **2) 라즈베리파이 카메라 자동 촬영 프로그램 개발**

많은 촬영 과정이 필요하기 때문에, 이 과정을 간소화하기 위한 프로그램을 개발한다. 프로그램의 개발 Flow는 다음과 같다.

![image-20240414223412354](/images/2024-04-14-Weekly diary(6주차)/image-20240414223412354.png){: .img-default-setting}

- ‘1’ 입력 시 preview가 동작한다. q를 눌러서 해당 명령을 탈출한다.
- ‘2’ 입력 시 사진 이름을 입력할 수 있도록 하고, 몇 초의 preview를 보여주며 촬영을 진행한다. 이후 촬영이 완료되면 드라이브에 자동 업로드되어 사진을 윈도우에서 즉각적으로 확인할 수 있도록 한다.

<br>

## **3) 조도 분석**

> 현재 시스템 환경에서는 원단에 가해지는 조명이 일정하다는 것을 신뢰할 수 없고, 그 뿐만 아니라 원단의 색 속성에 따라서 조도의 영향이 다르게 가해지는지 확인해야 한다. 이에 따라 임시로 원단을 촬영해 조도의 차이를 시각화하고, 이를 통해 색 속성에 따른 조도의 영향을 파악하여 시스템 환경 및 S/W를 개선하는데 활용한다.

### 샘플 예제 구성 방식

- **orig**: 원본 촬영 이미지
- **cropped**: 원본에서 적절한 구역을 자른 이미지
- **heatmap**: cropped 이미지에서 조도의 차이를 상대적으로 처리한 이미지

샘플 예제의 결과를 올바르게 해석하기 위해서는, 해당 결과가 어떻게 도출된 것인지 이해해야 한다.  
각 이미지는 모두 다음 process를 거쳐 생성된 것이다.
{: .notice--success .text-center}

1. 원본 이미지를 적절하게 **crop**한다. (*최대한 중앙이 나오도록 설정*)

2. crop된 이미지에서 **픽셀 별 밝기**(*brightness*)를 계산한다. 이때, **밝기**는 **아래 공식을 통해 계산**되었다. (이 공식은 RGB 색상 모델에서 휘도를 계산하는 데 사용하는 공식이다. 가중치 0.299, 0.587, 0.114는 각 색상이 인간 눈에 미치는 영향력을 반영한 것이다. *다른 공식을 적용할 경우, 결과가 다르게 산출될 수 있음에 주의해야 한다.*)

   ![image-20240414223524385](/images/2024-04-14-Weekly diary(6주차)/image-20240414223524385.png){: .img-width-large}

   > *위 공식을 적용할 경우, 최솟값은 0, 최댓값은 255이다.*

3. 구해진 밝기 값을 기준으로 **정규화**를 진행한다. 즉, 모든 값을 0과 1 사이의 값으로 변환한다. 예를 들어, 어떠한 cropped image에서 최댓값이 157이었고 최솟값이 25였다면, 157은 1이 되고, 25는 0이 된다.

4. 정규화된 이미지를 바탕으로 heatmap을 display합니다. 본 heatmap은 matplotlib의 inferno colormap이 쓰며, **어두울수록 검은색→파란색을, 밝을수록 빨간색→노란색을 매칭합니다.**

​	![image-20240414221346543](/images/2024-04-14-Weekly diary(6주차)/image-20240414221346543.png){: .img-width-large}

<br>

### 조도 분석 코드

- **visualize_swatch_brightness.py**

![code](/images/2024-04-14-Weekly diary(6주차)/code.png)

<br>

- **image_utility.py**

![code1](/images/2024-04-14-Weekly diary(6주차)/code1.png)

<br>

### 샘플 예제

- **floor**

  - floor (orig.)

  ![image-20240414222223254](/images/2024-04-14-Weekly diary(6주차)/image-20240414222223254.png)

  - floor (cropped)

  ![image-20240414222233264](/images/2024-04-14-Weekly diary(6주차)/image-20240414222233264.png)

  - floor (heatmap)

  ![image-20240414222241315](/images/2024-04-14-Weekly diary(6주차)/image-20240414222241315.png)

<br>

- **black**

  - black (orig.)

  ![image-20240414222305226](/images/2024-04-14-Weekly diary(6주차)/image-20240414222305226.png)

  - black (cropped)

  ![image-20240414222315628](/images/2024-04-14-Weekly diary(6주차)/image-20240414222315628.png)

  - black (heatmap)

![image-20240414222327576](http://localhost:4000/images/2024-04-14-Weekly%20diary(6%EC%A3%BC%EC%B0%A8)/image-20240414222327576.png)

<br>

- **blue**

  - blue (orig.)

  ![image-20240414222344085](/images/2024-04-14-Weekly diary(6주차)/image-20240414222344085.png)

  - blue (cropped)

  ![image-20240414222358399](/images/2024-04-14-Weekly diary(6주차)/image-20240414222358399.png)

  - blue (heatmap)

​	![image-20240414222409092](/images/2024-04-14-Weekly diary(6주차)/image-20240414222409092.png)

- **light green**

  - light green (orig.)

  ![image-20240414222418165](/images/2024-04-14-Weekly diary(6주차)/image-20240414222418165.png)

  - light green (cropped)

  ![image-20240414222426807](/images/2024-04-14-Weekly diary(6주차)/image-20240414222426807.png)

  - light green (heatmap)

​	![image-20240414222518139](/images/2024-04-14-Weekly diary(6주차)/image-20240414222518139.png)

- light pink

  - light pink (orig.)

  ![image-20240414222600270](/images/2024-04-14-Weekly diary(6주차)/image-20240414222600270.png)

  - light pink (cropped)

  ![image-20240414222614612](/images/2024-04-14-Weekly diary(6주차)/image-20240414222614612.png)

  - light pink (heatmap)

​	![image-20240414222628774](/images/2024-04-14-Weekly diary(6주차)/image-20240414222628774.png)

- **light yellow**

  - light yellow (orig.)

  ![image-20240414222637731](/images/2024-04-14-Weekly diary(6주차)/image-20240414222637731.png)

  - light yellow (cropped)

  ![image-20240414222652695](/images/2024-04-14-Weekly diary(6주차)/image-20240414222652695.png)

  - light yellow (heatmap)

​	![image-20240414222703765](/images/2024-04-14-Weekly diary(6주차)/image-20240414222703765.png)

- **red**

  - red (orig.)

  ![image-20240414222712747](/images/2024-04-14-Weekly diary(6주차)/image-20240414222712747.png)

  - red (cropped)

  ![image-20240414222723008](/images/2024-04-14-Weekly diary(6주차)/image-20240414222723008.png)

  - red (heatmap)

​		![image-20240414222731483](/images/2024-04-14-Weekly diary(6주차)/image-20240414222731483.png)

- **white**

  - white (orig.)

  ![image-20240414222740253](/images/2024-04-14-Weekly diary(6주차)/image-20240414222740253.png)

  - white (cropped)

  ![image-20240414222749728](/images/2024-04-14-Weekly diary(6주차)/image-20240414222749728.png)

  - white (heatmap)

  ![image-20240414222759662](/images/2024-04-14-Weekly diary(6주차)/image-20240414222759662.png)

<br>

### 결과 해석

1. **파란색 계열과 빨간색 계열의 원단이 전반적으로 어둡게 보인다.**

   본 실험 결과에 따르면 **파란색** 및 **빨간색** 계열의 원단이 전반적으로 **어둡게 보인다.** 이는 밝기 계산 공식에서 파란색과 빨간색에 낮은 가중치를 부여한 결과이며, 이는 인간의 시각적 민감도를 반영하는 것으로 합리적인 접근이라 할 수 있다. 실제로 이러한 색상의 원단은 눈에 어둡게 보이는 경향이 있다. 추후에는 **다른 방식 적용도 고려 필요하다**고 생각된다.

   <br>

2. **조도 차이는 분명히 존재한다.**

   **검은색(black), 파란색(blue), 빨간색(red)** 등에서 조명의 위치에 따라 발생하는 조도 차이가 명확하게 관찰되었다. **중앙보다 가장자리에 조명이 설치된 환경에서 중앙 부위가 상대적으로 어둡게 나타났다.** 특히 **검은색**에서 이 현상이 가장 두드러졌으며, 이는 어두운 색일수록 조도의 영향을 더 많이 받기 때문이다. 밝은 색상에서는 조도 차이가 거의 나타나지 않는 것으로 확인되었으며, 이는 어두운 색상에서 빛의 난반사가 적게 발생하기 때문일 것이다. 원단의 고유한 무늬에 대한 고려도 필요할 것으로 보인다.

   <br>

3. **원사의 직조에 의해 생기는 음영에 대해서 면밀히 분석해야 한다.**

   **밝은색 원단에서 상대적으로 빨간색이 강하게 나타나는 현상은** **원사의 직조에 의해 발생하는 음영 때문이다.** 원단의 표면이 밝게 표현되더라도, 원사의 음영이 원단의 색상 표현에 큰 영향을 미치기 때문이다. 이러한 음영은 원단의 고유한 무늬로 나타나며, 이미지를 확대해 볼 때 이러한 특징이 뚜렷하게 확인된다. 따라서 알고리즘 개발에 착수하기 전에 이러한 차이를 명확히 인지하고 고려하는 것이 중요하다.

   이 결과는 다음 단계의 연구 방향성 설정과 알고리즘 개선에 중요한 기초 자료로 활용될 수 있다.

<br>

------

# 5. 향후 계획

## 1) Clustering 팀

> Clustering 팀에서는 기존 클러스터링 방식의 문제점을 해결하기 위해 고해상도 이미지를 처리할 방법을 고안해야 한다. 이를 위해 전처리 과정을 적용하거나 torch와 cuda를 이용하는 새 코드를 구현하는 등 다양한 방법을 시도해보아야 하고 초기부터 고려했던 점인 색 계열의 차이가 클러스터링에 주는 영향도 지속적으로 신경을 써야 한다.

- [ ] 이미지 전처리를 통한 고해상도 이미지 처리 방법 모색
- [ ]  pytorch을 통한 DBSCAN 코드 구현

## 2) Calibration 팀

> Calibration팀에서는 촬영된 원단 이미지를 기준으로, 보정이 어떻게 되어야 할지 대표 색상 추출과 함께 확인해야 한다. 이에 대해 지역적 조도 차이에 대한 분석이 필요하며, 유의미한 조도 차이가 존재할 시, LED의 위치를 변경하는 것을 고려해야 한다. 또한, TPG에서도 색조 변화가 발생하는지 확인하고 필요한 보정 방안을 고민해 보기로 한다. 새로운 기준을 마련하여 색상 Balancing 알고리즘을 개발하거나, TPG를 지역 별로 촬영하여 Target Area의 크기를 가정함으로써 지역적 조도 차이를 반영할 수 있는지도 검토한다.

- [ ]  촬영 과정 간소화할 수 있는 프로그램 완성
- [ ]  촬영물의 색조에 따라 발생하는 색온도 변화 보정 방법 모색
- [ ]  지역별 조도 차이에 따른 색차 보정값 고려

## 3) 공통 계획

- [ ]  TPG 촬영